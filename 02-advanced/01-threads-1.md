# マルチスレッド

# 第1部：マルチスレッドプログラミングについて

## 1.そもそもスレッドとは

プログラム中の１つの制御の流れのこと。CPUは１コアで１つの処理しか動かせないが、それを複数あるかのように仮想的に見せる仕組みや環境を表す。

Windows/Linux/macOSなどのOSにおいて、スレッドは特定のプロセスに属する形で存在し、プロセスは複数のスレッドを保持・実行できる。スレッド間では親となるプロセスの情報を共有するが、スレッド間では独立した実行コンテキストを持つ。

* スレッドの実行コンテキスト：
    * スタック領域
    * CPUのレジスタセット(プログラムカウンタ、スタックポインタや各種汎用レジスタ)
    * スレッドローカル変数
    * 優先度などの属性

複数のスレッドを独立して動かし、時には協調させて目的の処理を行わせるプログラムを『マルチスレッドプログラム』と呼び、そのためのプログラミング技術を一般的に『マルチスレッドプログラミング』と呼ぶ。

### 1.1.プロセスとスレッドの違い

どちらも複数の制御の流れを並行して動かすものだが、端的に言うと独立して持つ実行コンテキストの規模・レイヤーが異なる。

* プロセスの実行コンテキスト
    * 仮想アドレス空間
    * ファイル/ネットワーク/デバイスなどIOやリソースへのアクセス権
    * どのユーザーの下で動いているか
    * 環境変数など

スレッドはプロセスに属するため、上記を同一プロセス内の別スレッドとで共有する。

* プロセスは独立した仮想アドレス空間を持つ
    * ⇔スレッドは同一プロセス(システム)内で仮想アドレス空間を共有する
* プロセスの方がスレッドよりも生成コスト・切替コストが大きい
    * ポインタの差し替えだけでなくCPU,TLBキャッシュクリアも含むため
        * TLB: Translation Lookaside Buffer
    * 参考： https://naoya-2.hatenadiary.org/entry/20071010/1192040413

|スレッド|プロセス|
|---|---|
|プログラムカウンタ<br>スタック<br>汎用レジスタの内容<br>スレッドの属性|仮想アドレス空間<br>大域変数<br>開いたファイル<br>タイマー<br>シグナル<br>セマフォ<br>ユーザー情報|

（http://www.atdot.net/~ko1/activities/sasada_gt.pdf 「表1.1:スレッドとプロセスの基本的な情報」より）


> #### **[補足1]タスクとスレッドの違い**
>
> RTOSのタスクとスレッドは技術的には同じもの。扱う実行コンテキストもタスクとスレッドで違わない。
>
> * タスクもスレッドも同じ粒度の実行コンテキストを持つ
>     * 実行可能状態(RUNNING/READY/...など),優先度なども同じ
> * タスクはRTOSにおける用語。スレッドはマルチプロセスOSにおける用語
> * 「親」が異なる
>     * **タスクの親**：OS。
>         * プロセス/仮想アドレスという概念が(大抵)ないため
>         * 各タスクはOSの全てのリソースを共有する
>         * OS∋タスク の関係
>     * **スレッドの親**：プロセス。
>         * 各スレッドは所属するプロセスのリソースを共有するが、別のプロセスのリソースにはさわれない
>         * OS∋プロセス∋スレッド の関係
> * T-KernelなどのRTOSでは１システム１アプリケーションなので、システム上でタスクが直接動く
> 
> タスクとスレッドが違うのではなく、扱うOSにおいてタスク/スレッドの意味づけが違うという認識でOK。
> 
> ・・・ちなみにRTOSだとタスク生成時にどういう設定でシステムリソースを消費するか等を制限の多い環境下で細かく指定しないといけない。そのため調整がスレッドに比べて大変（調整相手に人間も加わってくるなど）。
>
> （ついでに言うとRTOSにおいてはOSで言うタスクとCPU用語のタスクとを区別しておくと良い）

> #### **[補足2]並行処理と並列処理の違い**
>
> 『並行』と『並列』は異なるので、言葉の使い分けに注意。
>
> * **並行(Concurrent)**: 1CPU上で複数の処理を行うような動作。実際に動いているスレッドが切り替わりつつ、１つだけの計算資源を譲り合いながら使っていく
> * **並列(Parallel)**: 複数の処理が本当に同時に動いているような動作。マルチCPU、マルチコアな環境での動作。
> 
> 最近のアプリ界隈ではマルチプロセッサがデフォルトなので、コンカレントが並行と並列の両方の意味を持って使われることが多く、パラレルは並行と区別したいときのみ使われる

### 1.2.マルチスレッドプログラミングは何を解決するか

マルチスレッドで実装することで解決する問題は以下。

* 並行処理実現の簡便化
    * 同時に複数のことを行いやすくなる
* 資源の有効活用
    * CPUの空き時間を減らせる(待ち状態でも他のことができる)
    * [統計多重効果](https://eng-blog.iij.ad.jp/archives/9820)を期待

一方で、マルチスレッドプログラミングを行う上で**必ず**解決しておかなければならない問題は以下。

* データ競合: 複数のスレッドから同時に同じオブジェクトを読み書きしてしまうこと
    * データの不整合が発生し、実行結果として何が起こるかわからなくなる
* 処理の停止: スレッドがCPU資源を確保できなくなり処理が進行しなくなること
    * デッドロック/ライブロック/スタベーション(優先順位の逆転を含む)
    * プログラムを進められなくなる

一般的にデータ競合を回避するためのロック機構を導入すると、後者のデッドロック問題が発生するようになる。デッドロックを回避するC++のAPIは存在しないため（他言語でも同じ）、つまりロックや同期処理の使い方に習熟しなければならない。

> #### **[補足3]非同期処理とマルチスレッドの違い**
> 
> 直交する概念で、別物。[このサイトの説明](https://dodosu.hatenablog.jp/entry/2021/04/22/182328)を借りると、
>
> * 同期処理と非同期処理の違い＝待つか待たないか。
> * シングルスレッドとマルチスレッドの違い＝単線か複線か。
>
> となる。非同期/同期式のスレッドというのはなく、スレッドは個々に独立して動作していて結果として非同期になるというだけの話。

## 2.マルチスレッドプログラミングのポイント

### 2.1.スレッドで変数(同じメモリ空間)を出来るだけ共有しない
* `std::unique_ptr`などを使い、受け渡すときは`std::move()`で所有権を手放す
* 共有可能な変数（≠定数）を出来るだけ作らない
    * グローバル変数、静的変数など

### 2.2.スレッドで共有するデータは出来るだけimmutableにする
* 変更できないデータならばどれだけ共有しても安全
* 規模によってはドメイン駆動設計本に出てくるイベントソーシングやデータ指向プログラミング本のimmutableなデータ構造のような仕組みを検討する

### 2.3.クリティカルセクションを見定め小さく排他する
* クリティカルセクション=複数スレッドから参照/更新されうる変数などの状態のこと
* 非同期メッセージング機構や排他を考える
* 排他が多い・大きいほど恩恵は減っていく
    * PythonのGIL(Global Interpreter Lock)
    * 状態の更新より参照の方が多い場合はリーダーライターロックを使う、単一の値だけ排他する場合はアトミック変数(`std::atomic`クラス)を使う、など

### 2.4.作りたいスレッドモデルを意識して書く
行いたい処理によって適した設計がある。

* **アクター・ベース**: 一言でいうと「(仕事よりも)スレッドが偉い」というアプローチ
    * スレッドを表すオブジェクトに対して、仕事を行うための情報を持たせて動かす
        * 他スレッドから受け取った情報で処理を行い、自分の内部状態を変化させる
    * スレッド同士がやりとりする情報を小さく・軽くできる
    * ある処理を実行するスレッドが何か決まっている
    * Active Objectパターン
* **タスク・ベース**： 一言でいうと「(スレッドよりも)仕事が偉い」というアプローチ
    * 処理に必要な情報を、スレッドではなくスレッド同士がやりとりするオブジェクトに持たせる
    * オブジェクトはメッセージ/リクエスト/コマンドなどと呼ばれる
    * 処理を実行するのはどのスレッドでも良い
    * Worker Thread, Thread Poolパターン
* **並列データ・ベース**: 配列の要素のような同格なデータを一斉に処理するアプローチ
    * GPGPU, SIMD, OpenMP, **Parallel STL**
* プログラムの中に大抵それぞれが混在する。ある並行処理がどのアプローチが適しているかを意識する

> #### **[補足]マルチスレッドプログラミング注意点の歴史**
>
> 歴史的な変遷として、マルチスレッドプログラミングの注意点は
> 
> 1. セマフォやmutexで適切なロックをかけること・リエントラントにすること
> 2. そもそも共有するデータを減らすこと
> 3. --- (マルチスレッド向けデザインパターンでどうにか隠蔽しよう時代) ---
> 4. データをimmutableにすること
> 5. ↑をプログラミング言語の仕様として定義すること
> 
> という流れでトレンドが変化してきている(注:個人の感想)。C/C++では5をいまさら実現できないので、いろいろと頑張る必要があるわけで…。
