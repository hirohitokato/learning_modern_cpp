# マルチスレッド

# 第1部：マルチスレッドプログラミングについて

## 1.そもそもスレッドとは

プログラム中の１つの制御の流れのこと。CPUは１コアで１つの処理しか動かせないが、それを複数あるかのように仮想的に見せる仕組みや環境を表す。

Windows/Linux/macOSなどのOSにおいて、スレッドは特定のプロセスに属する形で存在し、プロセスは複数のスレッドを保持・実行できる。スレッド間では親となるプロセスの情報を共有するが、スレッド間では独立した実行コンテキストを持つ。

* スレッドの実行コンテキスト：
    * スタック領域
    * CPUのレジスタセット(プログラムカウンタ、スタックポインタや各種汎用レジスタ)
    * スレッドローカル変数
    * 優先度などの属性

複数のスレッドを独立して動かし、時には協調させて目的の処理を行わせるプログラムを『マルチスレッドプログラム』と呼び、そのためのプログラミング技術を一般的に『マルチスレッドプログラミング』と呼ぶ。

### 1.1.プロセスとスレッドの違い

端的に言うと、独立して持つ実行コンテキストの規模・レイヤーが異なる。

* プロセスの実行コンテキスト
    * 仮想アドレス空間
    * ファイル/ネットワーク/デバイスなどIOやリソースへのアクセス権
    * どのユーザーの下で動いているか
    * 環境変数など

スレッドはプロセスに属するため、上記を同一プロセス内の別スレッドとで共有する。

* プロセスは独立した仮想アドレス空間を持つ
    * ⇔スレッドは同一プロセス(システム)内で仮想アドレス空間を共有する
* プロセスの方がスレッドよりも生成コスト・切替コストが大きい
    * ポインタの差し替えだけでなくCPU,TLBキャッシュクリアも含むため
    * 参考： https://naoya-2.hatenadiary.org/entry/20071010/1192040413

|スレッド|プロセス|
|---|---|
|プログラムカウンタ<br>スタック<br>汎用レジスタの内容<br>スレッドの属性|仮想アドレス空間<br>大域変数<br>開いたファイル<br>タイマー<br>シグナル<br>セマフォ<br>アカウント情報|

（http://www.atdot.net/~ko1/activities/sasada_gt.pdf 表1.1:スレッドとプロセスの基本的な情報 より）


> #### **[補足1]タスクとスレッドの違い**
>
> タスクとスレッドは技術的には同じもの。扱う実行コンテキストもタスクとスレッドで違わない。
>
> * タスクもスレッドも同じ粒度の実行コンテキストを持つ
>     * 実行可能状態(RUNNING/READY/...など),優先度なども同じ
> * タスクはRTOSにおける用語。スレッドはマルチプロセスOSにおける用語
> * 「親」が異なる
>     * **タスクの親**：OS。
>         * プロセス/仮想アドレスという概念が(大抵)ないため
>         * 各タスクはOSの全てのリソースを共有する
>         * OS∋タスク の関係
>     * **スレッドの親**：プロセス。
>         * 各スレッドは所属するプロセスのリソースを共有するが、別のプロセスのリソースにはさわれない
>         * OS∋プロセス∋スレッド の関係
> * RTOSでは１システム１プログラムなので、システム上でタスクが直接動く
> 
> タスクとスレッドが違うのではなく、扱うOSにおけるタスク/スレッドの位置づけが違うという認識でOK。あるいは以下の関係で捉えてもよい。
> 
> * タスク ≒ カーネルレベルスレッド
> * スレッド ≒ ユーザーレベルスレッド
> 
> ・・・ちなみにタスクだと生成時にどういう設定でシステムリソースを消費するか等を、制限の多い環境下で細かく指定しないといけないので、調整がスレッドに比べて大変（調整相手に人間も加わってくるなど）。

> #### **[補足2]並行と並列の違い**
>
> 『並行』と『並列』は異なるので、言葉の使い分けに注意。
>
> * **並行(Concurrent)**: 1CPU上で複数の処理を行うような動作。実際に動いているスレッドが切り替わりつつ、１つだけの計算資源を譲り合いながら使っていく
> * **並列(Parallel)**: 複数の処理が本当に同時に動いているような動作。マルチCPU、マルチコアな環境での動作。
> 
> 最近のアプリ界隈ではマルチプロセッサがデフォルトなので、コンカレントが並行と並列の両方の意味を持って使われることが多く、パラレルは並行と区別したいときのみ使われる

### 1.2.マルチスレッドプログラミングは何を解決するか

マルチスレッドで実装することで解決する問題は以下。

* 並行処理実現の簡便化
    * 同時に複数のことを行いやすくなる
* 資源の有効活用
    * CPUの空き時間を減らせる
    * 統計多重効果

一方で、マルチスレッドプログラミングを行う上で**必ず**解決しておかなければならない問題は以下。

* データ競合: 複数のスレッドから同時に同じオブジェクトを読み書きしてしまうこと
    * データの不整合が発生し、実行結果として何が起こるかわからなくなる
* デッドロック: 複数スレッドがお互いに処理完了を待ち合わせてしまい、処理が進行しなくなること
    * プログラムを進められなくなる

データ競合を回避するためのロック機構を導入すると、後者のデッドロック問題が発生するようになる。デッドロックを回避するC++のAPIは存在しないため（他言語でも同じ）、つまりロックや同期処理の使い方に習熟しなければならない。

## 2.マルチスレッドプログラミングのポイント

### 2.1.スレッドで値(同じメモリ空間)を共有しない
* `std::unique_ptr`などを使い、受け渡すときは`std::move()`などで所有権を手放す
* 共有可能な変数（≠定数）を出来るだけ作らない
    * グローバル変数、静的変数など

### 2.2.スレッドで共有するデータはimmutableにする
* 変更できないデータならばどれだけ共有しても安全

### 2.3.作っているスレッドモデルがアクター・ベースなのかタスク・ベースなのかを意識して書く
* **アクター・ベース**: 一言でいうと「(仕事よりも)スレッドが偉い」というアプローチ
    * スレッドを表すオブジェクトに対して、仕事を行うための情報を持たせて動かす
        * 他スレッドから受け取った情報で処理を行い、自分の内部状態を変化させる
    * スレッド同士がやりとりする情報を小さく・軽くできる
    * ある処理を実行するスレッドが何か決まっている
    * Active Objectパターン
* **タスク・ベース**： 一言でいうと「(スレッドよりも)仕事が偉い」
    * 処理に必要な情報を、スレッドではなくスレッド同士がやりとりするオブジェクトに持たせる
    * オブジェクトはメッセージ/リクエスト/コマンドなどと呼ばれる
    * 処理を実行するのはどのスレッドでも良い
    * Worker Thread, Thread Poolパターン
* プログラムの中に双方が混在するのはOK。あるスレッドがどちらの視点で作っているかを意識する

> #### **[補足]マルチスレッドプログラミング注意点の歴史**
>
> 歴史的な変遷として、マルチスレッドプログラミングの注意点は
> 
> 1. セマフォやmutexで適切なロックをかけること・リエントラントにすること
> 2. そもそも共有するデータを減らすこと
> 3. --- (マルチスレッド向けデザインパターンでどうにか隠蔽しよう時代) ---
> 4. データをimmutableにすること
> 5. ↑をプログラミング言語の仕様として定義すること
> 
> という流れでトレンドが変化してきている(注:個人の感想)。C/C++では5をいまさら実現できないので、いろいろと頑張る必要があるわけで…。
