# 排他処理

スレッド間で共有している変数/デバイスなどのリソースを排他的に使用したい場合に用いる処理。

* ロック獲得 ＝ 排他的な処理権を手に入れる
* ロック解放 ＝ 手に入れた処理権を手放す

ロック獲得～解放で囲まれた、排他させたい処理のまとまりのことを「クリティカルセクション」と呼ぶ。

## 1.ロックの種類

|型|ver.|説明|
|---|---|---|
|`std::mutex`||ロック/非ロックで排他領域を作り出せる|
|`std::recursive_mutex`||同じスレッドであれば何回でも`lock()`できる|
|`std::shared_mutex`|C++17|リーダーライターロックを提供|
|`std::shared_timed_mutex`|C++14|タイマー付のリーダーライターロックを提供|
|`std::counting_semaphore`|C++20|計数セマフォ|
|`std::binary_semaphore`|C++20|バイナリセマフォ。`counting_semaphore<1>`と同じ|
|`std::latch`|C++20|ラッチ通過/到達スレッドが期待個数になるまで複数スレッドの進行をブロックする処理を提供|

* `std::recursive_mutex`はスレッドごとにロックを所有する仕組みのため、別のスレッドで`unlock()`しても効果なし
* `std::binary_semaphore`/`std::counting_semaphore`は別スレッドからの`release()`が可能

### ミューテックス

### 共有ミューテックス(Reader-Writer Lock)

### セマフォ

「何人までが同時にクリティカルセクションに入れる」を実現する仕組み。

* セマフォの獲得(`acquire()`)： 排他処理権の獲得。内部カウンタ－１。内部カウンタが０のときは待ち合わせ
* セマフォの解放(`release()`)： 排他処理権の解放。内部カウンタ＋１

カウンタの上げ下げは任意のスレッドから行えるので、あるスレッドで待ち合わせている処理を他のスレッドから解放することができる。

### ラッチ

「カウンタがゼロになったタイミングで待っていた処理をスタート」を実現する仕組み

* カウンタの減算(`count_down()`)： あらかじめ決められたカウンタを減算する。ゼロになったら待機しているスレッドを動かす

この仕組みを使うと、状態変数(condition value)を使ったスレッド間の待ち合わせ処理がよりシンプルに書ける。

> 過去に「複数のスレッドでのそれぞれの初期化処理が終わったら、メインスレッドでの処理を再開する」という処理を書いたことがありますが、この`std::latch`があればもっと楽に書けてました…

* ラッチオブジェクトは1回だけ使用でき、カウンタ値が0に到達したオブジェクトの再利用はできない。 再利用したい場合はバリア`std::barrier`を使う。
* セマフォが「カウンタがゼロになるまで獲得可」に対してラッチは「カウンタがゼロになったら獲得可」なので、対になっている。

## 2.ロック獲得/解放処理の便利メソッド

RAIIあるいは[Scoped Locking Pattern](https://www.dre.vanderbilt.edu/~schmidt/PDF/ScopedLocking.pdf)と呼ばれる方法で、スコープの寿命にロック獲得/解放を同期させるための管理メソッド群が用意されている。

スコープの先頭でこの型を用いた変数を定義するだけでロック解放処理をいちいち書かなくて済むので、非常に楽。

|型|ver.|説明|
|---|---|---|
|`std::lock_guard`||シンプルなロック獲得/解放処理|
|`std::unique_lock`||`std::lock_guard`の高機能版|
|`std::shared_lock`|C++14|`std::shared_mutex`を共有ロック/解放する|
|`std::scoped_lock`|C++17|複数のミューテックスをまとめてロック/解放できる|

※ `std::shared_mutex`を占有してロックしたい場合は他の`std::lock_guard`/`unique_lock`/`scoped_lock`を使えば良い
