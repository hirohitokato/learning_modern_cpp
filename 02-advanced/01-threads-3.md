# 排他処理

スレッド間で共有している変数/デバイスなどのリソースを排他的に使用したい場合に用いる処理。

* ロック獲得 ＝ 排他的な処理権を手に入れる
* ロック解放 ＝ 手に入れた処理権を手放す

ロック獲得～解放で囲まれた、排他させたい処理のまとまりのことを「クリティカルセクション」と呼ぶ。

## 1.ロックの種類

|型|ver.|説明|
|---|---|---|
|`std::mutex`||ロック/アンロックで排他領域を作り出せる|
|`std::recursive_mutex`||同じスレッドであれば何回でも`lock()`できる。Javaの`synchronized{}`、C#の`lock(obj){}`と同じ|
|`std::shared_mutex`|C++17|いわゆるリーダーライターロックを提供|
|`std::shared_timed_mutex`|C++14|タイマー付のリーダーライターロックを提供|
|`std::counting_semaphore`|C++20|計数セマフォ|
|`std::binary_semaphore`|C++20|バイナリセマフォ。`counting_semaphore<1>`と同じ|
|`std::latch`|C++20|ラッチ通過/到達スレッドが期待個数になるまで複数スレッドの進行をブロックする処理を提供|

* `std::recursive_mutex`はスレッドごとにロックを所有する仕組みのため、別のスレッドで`unlock()`しても効果なし
* `std::binary_semaphore`/`std::counting_semaphore`は別スレッドからの`release()`が可能

### ミューテックス

ロック/アンロック操作によって、その後のクリティカルセクションを実行できる権利を許可したり、許可されるまで待たせるための仕組み

### 共有ミューテックス(Reader-Writer Lock)

クリティカルセクションに「時間がかかる重い処理」「時間のかからない軽い処理」の２種類があり、後者で使うケースが非常に多い場合に効率的なロックを実現する仕組み。

ロック方法に２種類用意することで、時間のかかる重い処理は単一のスレッドのみ侵入できるが、時間のかからない処理は複数のスレッドが同時に進入できるようになっている。

前者の時間のかかる処理はファイルやDBへの書き込み処理が該当し、後者は読み込んだ内容(キャッシュ含む)を参照する処理が該当することから、一般的に「リーダーライターロック」とも呼ばれる。

### セマフォ

「何人まで同時にクリティカルセクションに入れる」を実現する仕組み。（ミューテックスは同時に入れるのは１人だけ）

* セマフォの獲得(`acquire()`)： 排他処理権の獲得。内部カウンタ－１。内部カウンタが０のときは待ち合わせ
* セマフォの解放(`release()`)： 排他処理権の解放。内部カウンタ＋１

カウンタの上げ下げは任意のスレッドから行えるので、あるスレッドで待ち合わせている処理を他のスレッドから解放することができる。

### ラッチ

「カウンタがゼロになったタイミングで待っていた処理をスタート」を実現する仕組み

* カウンタの減算(`count_down()`)： あらかじめ決められたカウンタを減算する。ゼロになったら待機しているスレッドを動かす

この仕組みを使うと、状態変数(condition value)を使ったスレッド間の待ち合わせ処理がよりシンプルに書ける。

> 過去に「複数のスレッドでのそれぞれの初期化処理が終わったら、メインスレッドでの処理を再開する」という処理を書いたことがありますが、この`std::latch`があればもっと楽に書けてました…

* ラッチオブジェクトは1回だけ使用でき、カウンタ値が0に到達したオブジェクトの再利用はできない。 再利用したい場合はバリア`std::barrier`を使う。
* セマフォが「カウンタがゼロになるまで獲得可」に対してラッチは「カウンタがゼロになったら獲得可」なので、対になっている。

## 2.ロック獲得/解放処理の便利メソッド

RAIIあるいは[Scoped Locking Pattern](https://www.dre.vanderbilt.edu/~schmidt/PDF/ScopedLocking.pdf)と呼ばれる方法で、スコープの寿命にロック獲得/解放を同期させるための管理メソッド群が用意されている。

スコープの先頭でこの型を用いた変数を定義するだけでロック解放処理をいちいち書かなくて済むので、非常に楽。

|型|ver.|説明|
|---|---|---|
|`std::lock_guard`||シンプルなロック獲得/解放処理|
|`std::unique_lock`||`std::lock_guard`の高機能版|
|`std::shared_lock`|C++14|`std::shared_mutex`を共有ロック/解放する|
|`std::scoped_lock`|C++17|複数のミューテックスをまとめてロック/解放できる|

* ※ `std::shared_mutex`を占有してロックしたい場合は他の`std::lock_guard`/`unique_lock`/`scoped_lock`を使えば良い
* ※ `std::lock_guard`は今後`std::scoped_lock`に取って代わるという話もあるので、使い慣れておくと良い