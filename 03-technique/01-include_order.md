# includeの順序のガイドライン

## そもそもincludeは何をしているのか

* 書いた場所にそのファイル内容をコピペしているだけ
    * コンパイラによるコンパイル前の、プリプロセッサの仕事
    * プリプロセッサは「コメントの削除」「`#`から始まるプリプロセッシングディレクティブの処理」の２つを行う
        * `#include …`は後者の仕事
* だからこんな書き方もできる

```cpp
//  data.csvの中身
1,2,3,4

// main.cpp
#include <vector>

int main() {
    std::vector<int> array {
        #include "data.csv"
    };
    return 0;
}
```

### `#include<〜>`と`#include ""`の違い

どのディレクトリを探すかの違い

|ディレクティブ|ディレクトリの検索順序|
|`#include<〜>`|処理系指定のインクルードパスからのみ検索|
|`#include ""`|まずカレントディレクトリを検索、次に処理系指定のインクルードパスを検索|

* 処理系指定のインクルードパス: Visual Studioでいうプロジェクトプロパティ→C/C++→追加のインクルードディレクトリ

### インクルードガード


## includeの順序/書き方

### `.h`ファイル

* ヘッダファイルだけでコンパイルができるよう、自己完結型にしておくこと
    * → ヘッダファイルに書かれている型は、すべてヘッダファイルでincludeする

[Google C++ スタイルガイドの「自己完結型ヘッダー」項](https://ttsuki.github.io/styleguide/cppguide.ja.html#Self_contained_Headers)によると、ヘッダファイル(.h)におけるインクルードの順序は以下を推奨している。


### `.cpp`ファイル

[Google C++ スタイルガイドの「インクルードの名前と順序」項](https://ttsuki.github.io/styleguide/cppguide.ja.html#Names_and_Order_of_Includes)によると、ソースコード(.cpp)におけるインクルードの順序は以下を推奨している。

1. 紐付くヘッダー(`myclass.cpp`なら`myclass.h`)
2. C言語のシステムヘッダー(`cstdio`, `cmath`など)
3. C++標準ライブラリヘッダー(`vector`, `string`など)
4. その他のライブラリのヘッダー(`boost/asio`, `sqlite3.h`など)
5. 自分のプロジェクト内のヘッダー(`otherclass.h`など)

それぞれのグループの間には空行を1行入れると良い。

この順番にしておけば、紐付くヘッダーdir2/foo2.hで必要なインクルードを省いてしまったときに、dir/foo.ccやdir/foo_test.ccのビルドが失敗します。 このルールによって、ビルドが壊れたときに、他のパッケージで作業している無実の人ではなく、それらのファイルで作業をしていた本人に最初に見せることができます。



## ヘッダファイルをチューニングする意味

* コンパイル時間の短縮
* 依存関係の整理

*ヘッダファイルに書くのかcppに書くのか
    * 基本cppに書く
    * ヘッダファイルに登場する型はその限りではない
        * ただし前方宣言も同様に駆使すること
*インクルードの順序
    * 標準ライブラリ、サードパーティライブラリ、ローカルライブラリ、最後に自分のヘッダファイル
*その理由
    * コンパイル時間を短くするのが至上命題
    * このルールの出どころ
* STLに関係するものはヘッダファイルに書く
* ヘッダファイルのインクルードと前方宣言を使い分ける
