# include順序のガイドライン

## 1.そもそもincludeは何をしているのか

* 書いた場所にそのファイル内容をコピペしているだけ
    * コンパイラによるコンパイル前の、**プリプロセッサ**の仕事
    * ![](https://cdn-ak.f.st-hatena.com/images/fotolife/k/kamino-dev/20171209/20171209201347.png)
    * この中でプリプロセッサは「コメントの削除」「`#`から始まるプリプロセッシングディレクティブの処理」の２つを行う
        * `#include …`は後者の仕事
* だからこんな書き方もできる

```cpp
//  data.csvの中身
1,2,3,4

// main.cpp
#include <vector>

int main() {
    std::vector<int> array {
        #include "data.csv"
    };
    return 0;
}
```

### 1.1.`#include<〜>`と`#include ""`の違い

どのディレクトリを探すかの違い

|ディレクティブ|ディレクトリの検索順序|
|---|---|
|`#include<〜>`|処理系指定のインクルードパスからのみ検索|
|`#include ""`|まずカレントディレクトリを検索、次に処理系指定のインクルードパスを検索|

* 処理系指定のインクルードパス: Visual Studioだと「プロジェクトプロパティ」→「C/C++」→「追加のインクルードディレクトリ」

### 1.2.インクルードガード

`#ifndef/#define/#endif`を組み合わせることで、複数のファイルから同一のヘッダファイルをインクルードしても二重定義にならないで済む「インクルードガード(#define guard)」が実現できる。

```cpp
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```

* 今の大抵のコンパイラでは`#pragma once`が使えるのでそちらを使った方が簡単で安全
    * 上の`FOO_BAR_BAZ_H_`が別ファイルでも同じ名前で定義されているかもしれない

```cpp
// 上と同じ機能(＆より安全)
#pragma once

...
```

### 1.3.前方宣言

前方宣言とはある関数/クラス/構造体など何かの型に対する、定義のない宣言のこと。

```cpp
// いずれも実体は(まだ)ないが、型の存在だけを伝えられる
class B;
void FuncInB();
extern int variable_in_b;
ABSL_DECLARE_FLAG(flag_in_b);
```

これを使えば、ヘッダファイルをインクルードしなくても同じ型が使えるようになる。また、クラス定義の記述を整理することもできる(下例)。

```cpp
class B; // ←前方宣言でクラスBの存在を宣言

class A {
public:
    void SetObject(const &B obj);
private:
    B *obj_; // B objはNG
}

...

class B { ... } // 実際のBの定義
```


## 2.includeの順序/書き方

以下は[Google C++ スタイルガイド](https://ttsuki.github.io/styleguide/cppguide.ja.html)を参考にしている。

### 2.1.`.h`ファイル

* ヘッダファイルだけでコンパイルができるよう、自己完結型にしておくこと
    * → ヘッダファイルに書かれている型は、すべてヘッダファイルでincludeする

[Google C++ スタイルガイドの「自己完結型ヘッダー」項](https://ttsuki.github.io/styleguide/cppguide.ja.html#Self_contained_Headers)によると、ヘッダファイル(.h)におけるインクルードの順序は以下を推奨している。


### 2.2.`.cpp`ファイル

[Google C++ スタイルガイドの「インクルードの名前と順序」項](https://ttsuki.github.io/styleguide/cppguide.ja.html#Names_and_Order_of_Includes)によると、ソースコード(.cpp)におけるインクルードの順序は以下を推奨している。

1. 紐付くヘッダー(`myclass.cpp`なら`myclass.h`)
2. C言語のシステムヘッダー(`cstdio`, `cmath`など)
3. C++標準ライブラリヘッダー(`vector`, `string`など)
4. その他のライブラリのヘッダー(`boost/asio`, `sqlite3.h`など)
5. 自分のプロジェクト内のヘッダー(`otherclass.h`など)

それぞれのグループの間には空行を1行入れると良い。

```cpp
#include "myclass.h"

#include <cstdio>
#include <cmath>

#include <vector>
#include <string>

#include "boost/asio"
#include "sqlite3.h"

#include "app_entity.h"
#include "otherclasss.h"

...
```

この順番にしておけば、

* 上で記した自己完結型のヘッダーでないときにコンパイルエラーで気付ける
    * なんのファイルでエラーになったかがわかりやすくなる

というメリットが得られる。

## 3.その他の注意事項

### 3.1.必要なヘッダを直接インクルードする

* 必要なヘッダファイルをできるだけ明確に、冗長で良いのでインクルードする
    * 他ファイルを経由してインクルードしない
    * ヘッダーファイルの作者がインクルードを除外してしまうかもしれないため

### 3.2.前方宣言はなるべく利用しない

* メリットは確かにある
    * コンパイラが#includeによって多数のファイルを開いて処理する分のコンパイル時間を節約できる
    * 前方宣言と実装を分けることによって不必要な再コンパイルを抑制できる（コンパイル時間の短縮）
* しかし
    * 依存性を隠すため、必要なコードの再コンパイルをスキップしてしまうことがある
    * 将来の実装変更時に要変更箇所が散らばってしまうので、処理が壊れてしまう
    * `std::～`に対する前方宣言は未定義動作
* なので、前方宣言は自分のライブラリ内での使用に留める
    * 外部プロジェクトやライブラリの型に対して前方宣言を使用しない

# 質問

* publicのメソッドに引数でvectorを使っている。これはh/cppの両方でincludeすべき？
    * Googleのガイドラインだとhだけでなくcppでもincludeする
    * 個人的にはhファイルは必要だが、cppは任意(現場のルール次第)と考えている
    * 両方書いても問題はない
* プリコンパイル済みヘッダ(pch)
    * ビルド時間の短縮に寄与するので、作るのであれば作ってもいい
    * 配布の必要はない
    * C++20から「モジュール」もあるので調べてみると良いかも
    * (TODO)
* `#pragma once`に統一してよい？
    * ぜんぜんOK
* ヘッダファイルをまとめたヘッダファイルはあり？なし？
    * あり
    * 子どものヘッダファイルも自己完結型になるよう気をつけておく
* includeの相互参照があったけれど、どうしたら良い？
    * 前方宣言を使えばいいが、設計の問題でもある
        * 第3者のインターフェイス型を登場させて方向を単方向にしてあげる、など
